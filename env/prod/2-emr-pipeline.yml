AWSTemplateFormatVersion: 2010-09-09
Description: Cloudformation Template to spin up prod pipeline for EMR lab

Resources:

  # the random prefix used for naming all resources
  randomID:
    Type: "AWS::SSM::Parameter"
    Properties:
      Description: Random ID for prefixing automated.
      Type: String
      Value:
        Fn::Transform:
          Name: RandomString
          Parameters:
            Operation: lower
            Number: 6

  # The private key, keypair for EMR cluster and Parameter Store to retrieve the private key
  emrPrivateKey:
    Type: Custom::RSAKey
    Properties:
      Name:
        Fn::Join:
          - ''
          - - /emr-lab/private-key-
            - !GetAtt randomID.Value
      ServiceToken: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:binxio-cfn-secret-provider

  emrKeyPair:
    Type: Custom::KeyPair
    DependsOn: emrPrivateKey
    Properties:
      Name:
        Fn::Join:
          - ''
          - - emrLabKeyPair-
            - !GetAtt randomID.Value
      PublicKeyMaterial: !GetAtt emrPrivateKey.PublicKey
      ServiceToken: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:binxio-cfn-secret-provider

  # The network infrastructure for the EMR cluster (public subnet)
  emrInternetGateway:
    Type: AWS::EC2::InternetGateway

  emrVpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true

  emrVpcGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref emrVpc
      InternetGatewayId: !Ref emrInternetGateway

  emrRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref emrVpc

  enrRoute:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref emrInternetGateway
      RouteTableId: !Ref emrRouteTable

  emrSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: eu-west-1a
      VpcId: !Ref emrVpc
      CidrBlock: 10.0.1.0/16
      MapPublicIpOnLaunch: true

  emrSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref emrRouteTable
      SubnetId: !Ref emrSubnet

  emrMasterSecGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security for master node
      VpcId: !Ref emrVpc

  emrWorkerSecGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security for worker node
      VpcId: !Ref emrVpc

  # The role and instance profile to attach to the EMR cluster
  emrInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref emrRole

  emrRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonElasticMapReduceforEC2Role
      Policies:
        - PolicyName: "root"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: "*"
                Resource: "*"

  # The service role used by EMR service
  emrServiceRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - elasticmapreduce.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonElasticMapReduceRole

  # The security group to access Livy API
  lambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref emrVpc
      GroupDescription: Security group for Lambda function

  lambdaSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref lambdaSecurityGroup
      IpProtocol: tcp
      FromPort: 8998
      ToPort: 8998
      SourceSecurityGroupId: !Ref lambdaSecurityGroup

  # The EMR cluster supporting notebook on Master node
  emrCluster:
    Type: AWS::EMR::Cluster
    Properties:
      Name:
        Fn::Join:
          - ''
          - - emr-cluster-
            - !GetAtt randomID.Value
      Instances:
        MasterInstanceGroup:
          InstanceCount: 1
          InstanceType: m4.large
          Market: ON_DEMAND
          Name: Master node
        CoreInstanceGroup:
          InstanceCount: 4
          InstanceType: m4.large
          Market: ON_DEMAND
          Name: Core instance
        Ec2SubnetId: !Ref emrSubnet
        Ec2KeyName: !GetAtt emrKeyPair.Name
        AdditionalMasterSecurityGroups:
          - !Ref lambdaSecurityGroup
        EmrManagedMasterSecurityGroup: !Ref emrMasterSecGroup
        EmrManagedSlaveSecurityGroup: !Ref emrWorkerSecGroup
      Applications:
        - Name: Hadoop
        - Name: Spark
        - Name: Livy
      Configurations:
        - Classification: spark
          ConfigurationProperties:
            maximizeResourceAllocation: 'true'
      JobFlowRole: !Ref emrInstanceProfile
      ServiceRole: !Ref emrServiceRole
      ReleaseLabel: emr-5.22.0
      VisibleToAllUsers: true
      LogUri:
        Fn::Join:
          - ''
          - - s3://
            - !Ref emrLogBucket
            - "/logs/"

  # The bucket used to write data
  emrDataOutputBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        Fn::Join:
          - ''
          - - emr-lab-output-
            - !GetAtt randomID.Value

  # The bucket used to store EMR logs
  emrLogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        Fn::Join:
          - ''
          - - emr-lab-log-
            - !GetAtt randomID.Value

  # The custom resource used to cleanup the buckets before deletion
  cleanupLogBucketOnDelete:
    Type: Custom::cleanupbucket
    DependsOn: emrLogBucket
    Properties:
      ServiceToken: !GetAtt cleanBucketFunction.Arn
      BucketName: !Ref emrLogBucket

  cleanupDataBucketOnDelete:
    Type: Custom::cleanupbucket
    DependsOn: emrDataOutputBucket
    Properties:
      ServiceToken: !GetAtt cleanBucketFunction.Arn
      BucketName: !Ref emrDataOutputBucket

  cleanBucketFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          #!/usr/bin/env python
          # -*- coding: utf-8 -*-

          import json
          import boto3
          from botocore.vendored import requests

          def handler(event, context):
              try:
                  bucket = event['ResourceProperties']['BucketName']

                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          s3.Object(bucket.name, obj.key).delete()

                  sendResponseCfn(event, context, "SUCCESS")
              except Exception as e:
                  print(e)
                  sendResponseCfn(event, context, "FAILED")

          def sendResponseCfn(event, context, responseStatus):
              response_body = {'Status': responseStatus,
                              'Reason': 'Log stream name: ' + context.log_stream_name,
                              'PhysicalResourceId': context.log_stream_name,
                              'StackId': event['StackId'],
                              'RequestId': event['RequestId'],
                              'LogicalResourceId': event['LogicalResourceId'],
                              'Data': json.loads("{}")}

              requests.put(event['ResponseURL'], data=json.dumps(response_body))
      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt CleanBucketExecutionRole.Arn
      Timeout: 180

  CleanBucketExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: [lambda.amazonaws.com]
            Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: ['logs:*']
                Resource: 'arn:aws:logs:*:*:*'
        - PolicyName: s3Delete
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:*
                Resource:
                  - '*'

  # The custom resource to delete EMR managed security groups from the VPC
  cleanupEmrWorkerSecgroup:
    Type: Custom::cleanupEmrWorkerSecgroup
    Properties:
      ServiceToken: !GetAtt cleanupEmrSecgroupFunction.Arn
      SecGroupName: !Ref emrWorkerSecGroup

  cleanupEmrMasterSecgroup:
    Type: Custom::cleanupEmrMasterSecgroup
    Properties:
      ServiceToken: !GetAtt cleanupEmrSecgroupFunction.Arn
      SecGroupName: !Ref emrMasterSecGroup

  cleanupEmrSecgroupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          #!/usr/bin/env python
          # -*- coding: utf-8 -*-

          import json
          import boto3
          from botocore.vendored import requests

          def handler(event, context):
              try:
                  sgName = event['ResourceProperties']['SecGroupName']

                  if event['RequestType'] == 'Delete':
                      ec2 = boto3.resource('ec2')
                      secgroup = ec2.SecurityGroup(sgName)
                      print("Deleting rules for SG " + str(secgroup))
                      secgroup.revoke_ingress(IpPermissions=secgroup.ip_permissions)

                  sendResponseCfn(event, context, "SUCCESS")
              except Exception as e:
                  print(e)
                  sendResponseCfn(event, context, "FAILED")

          def sendResponseCfn(event, context, responseStatus):
              response_body = {'Status': responseStatus,
                              'Reason': 'Log stream name: ' + context.log_stream_name,
                              'PhysicalResourceId': context.log_stream_name,
                              'StackId': event['StackId'],
                              'RequestId': event['RequestId'],
                              'LogicalResourceId': event['LogicalResourceId'],
                              'Data': json.loads("{}")}

              requests.put(event['ResponseURL'], data=json.dumps(response_body))

      Handler: index.handler
      Role: !GetAtt cleanupEmrSecgroupRole.Arn
      Runtime: python3.6
      Timeout: 60

  cleanupEmrSecgroupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: LogsForLambda
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*"
        - PolicyName: EC2DescribeDeleleRevokeSg
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:Describe*
                  - ec2:DeleteSecurityGroup
                  - ec2:RevokeSecurityGroupIngress
                Resource: '*'
                Condition:
                  ArnEqualsIfExists:
                    ec2:Vpc: !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${emrVpc}"

  # Step functions

  lambdaStateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      Path: "/"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambdaFullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
        - arn:aws:iam::aws:policy/AWSStepFunctionsFullAccess

  stepFunctionsStateExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Path: "/"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.us-east-1.amazonaws.com
                - states.us-east-2.amazonaws.com
                - states.us-west-2.amazonaws.com
                - states.ap-northeast-1.amazonaws.com
                - states.ap-southeast-1.amazonaws.com
                - states.ap-southeast-2.amazonaws.com
                - states.ca-central-1.amazonaws.com
                - states.eu-central-1.amazonaws.com
                - states.eu-west-1.amazonaws.com
                - states.eu-west-2.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: state-execution-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: "*"

  # the Lambda function to get job status
  sparkJobStatusFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role:
        Fn::GetAtt:
          - lambdaStateMachineRole
          - Arn
      Code:
        ZipFile:
          Fn::Join:
            - "\n"
            - - from botocore.vendored import requests
              - import json
              - 'def lambda_handler(event, context):'
              - "  jobid = event.get('jobId')"
              - Fn::Join:
                  - ''
                  - - "  url = 'http://"
                    - Fn::GetAtt:
                        - emrCluster
                        - MasterPublicDNS
                    - ":8998/batches/' + str(jobid)"
              - "  res = requests.get(url)"
              - "  json_data = json.loads(res.text)"
              - "  return json_data.get('state')"
      Runtime: python3.6
      Timeout: '25'
      TracingConfig:
        Mode: Active
      VpcConfig:
        SecurityGroupIds:
          - Ref: lambdaSecurityGroup
        SubnetIds:
          - Ref: emrSubnet

  # The Lambda function to submit the raw ride job
  rawRideJobSubmitFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role:
        Fn::GetAtt:
          - lambdaStateMachineRole
          - Arn
      Code:
        ZipFile:
          Fn::Join:
            - "\n"
            - - from botocore.vendored import requests
              - import json
              - 'def lambda_handler(event, context):'
              - '  headers = { "content-type": "application/json" }'
              - Fn::Join:
                  - ''
                  - - "  url = 'http://"
                    - Fn::GetAtt:
                        - emrCluster
                        - MasterPublicDNS
                    - ":8998/batches'"
              - "  payload = {"
              - "    'file' : 's3://aws-data-lake-workshop/emr-lab/emr-lab-assembly-0.1.jar',"
              - "    'className' : 'RawRide',"
              - "    'args' : [event.get('yellowSource'), event.get('greenSource'),event.get('zonesSource'),event.get('rawRidesTarget')]"
              - "  }"
              - "  res = requests.post(url, data = json.dumps(payload), headers = headers,
              verify = False)"
              - "  json_data = json.loads(res.text)"
              - "  return json_data.get('id')"
      Runtime: python3.6
      Timeout: '60'
      TracingConfig:
        Mode: Active
      VpcConfig:
        SecurityGroupIds:
          - Ref: lambdaSecurityGroup
        SubnetIds:
          - Ref: emrSubnet

  # The Lambda function to submit the value ride job
  valueZoneJobSubmitFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role:
        Fn::GetAtt:
          - lambdaStateMachineRole
          - Arn
      Code:
        ZipFile:
          Fn::Join:
            - "\n"
            - - from botocore.vendored import requests
              - import json
              - 'def lambda_handler(event, context):'
              - '  headers = { "content-type": "application/json" }'
              - Fn::Join:
                  - ''
                  - - "  url = 'http://"
                    - Fn::GetAtt:
                        - emrCluster
                        - MasterPublicDNS
                    - ":8998/batches'"
              - "  payload = {"
              - "    'file' : 's3://aws-data-lake-workshop/emr-lab/emr-lab-assembly-0.1.jar',"
              - "    'className' : 'ValueZone',"
              - "    'args' : [event.get('rawRidesTarget'),event.get('valueZonesTarget')]"
              - "  }"
              - "  res = requests.post(url, data = json.dumps(payload), headers = headers,
              verify = False)"
              - "  json_data = json.loads(res.text)"
              - "  return json_data.get('id')"
      Runtime: python3.6
      Timeout: '60'
      TracingConfig:
        Mode: Active
      VpcConfig:
        SecurityGroupIds:
          - Ref: lambdaSecurityGroup
        SubnetIds:
          - Ref: emrSubnet

  # The step function to orchestrate the pipeline
  emrPipelineStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString:
        Fn::Join:
          - "\n"
          - - "{"
            - '   "Comment": "Spark ETL State Machine",'
            - '   "StartAt": "rawRide Job",'
            - '   "States": {'
            - '       "rawRide Job": {'
            - '           "Type": "Task",'
            - Fn::Join:
                - ''
                - - '           "Resource": "'
                  - Fn::GetAtt:
                      - rawRideJobSubmitFunction
                      - Arn
                  - "\","
            - '           "ResultPath": "$.jobId",'
            - '           "Next": "Wait for rawRide job to complete"'
            - "       },"
            - '       "Wait for rawRide job to complete": {'
            - '           "Type": "Wait",'
            - '           "Seconds": 60,'
            - '           "Next": "Query rawRide job status"'
            - "       },"
            - '       "Query rawRide job status": {'
            - '           "Type": "Task",'
            - Fn::Join:
                - ''
                - - '           "Resource": "'
                  - Fn::GetAtt:
                      - sparkJobStatusFunction
                      - Arn
                  - "\","
            - '           "Next": "rawRide job complete?",'
            - '           "ResultPath": "$.jobStatus"'
            - "       },"
            - '       "rawRide job complete?": {'
            - '           "Type": "Choice",'
            - '           "Choices": [{'
            - '               "Variable": "$.jobStatus",'
            - '               "StringEquals": "success",'
            - '               "Next": "valueZone Job"'
            - "           },{"
            - '               "Variable": "$.jobStatus",'
            - '               "StringEquals": "dead",'
            - '               "Next": "rawRide job failed"'
            - "           }],"
            - '           "Default": "Wait for rawRide job to complete"'
            - "       },"
            - '       "rawRide job failed": {'
            - '           "Type": "Fail",'
            - '           "Error": "rawRide Job",'
            - '           "Cause": "rawRide job job did not complete successfully.
             Please check logs."'
            - "       },"
            - '       "valueZone Job": {'
            - '           "Type": "Task",'
            - Fn::Join:
                - ''
                - - '           "Resource": "'
                  - Fn::GetAtt:
                      - valueZoneJobSubmitFunction
                      - Arn
                  - "\","
            - '           "ResultPath": "$.jobId",'
            - '           "Next": "Wait for valueZone job to complete"'
            - "       },"
            - '       "Wait for valueZone job to complete": {'
            - '           "Type": "Wait",'
            - '           "Seconds": 60,'
            - '           "Next": "Query valueZone job status"'
            - "       },"
            - '       "Query valueZone job status": {'
            - '           "Type": "Task",'
            - Fn::Join:
                - ''
                - - '           "Resource": "'
                  - Fn::GetAtt:
                      - sparkJobStatusFunction
                      - Arn
                  - "\","
            - '           "Next": "valueZone job complete?",'
            - '           "ResultPath": "$.jobStatus"'
            - "       },"
            - '       "valueZone job complete?": {'
            - '       "Type": "Choice",'
            - '       "Choices": [{'
            - '               "Variable": "$.jobStatus",'
            - '               "StringEquals": "success",'
            - '               "Next": "valueZone job finished"'
            - "           },{"
            - '               "Variable": "$.jobStatus",'
            - '               "StringEquals": "dead",'
            - '               "Next": "valueZone job failed"'
            - "           }],"
            - '           "Default": "Wait for valueZone job to complete"'
            - "       },"
            - '       "valueZone job failed": {'
            - '           "Type": "Fail",'
            - '           "Error": "valueZone Job",'
            - '           "Cause": "valueZone job did not complete successfully.
             Please check logs."'
            - "       },"
            - '       "valueZone job finished": {'
            - '           "Type": "Pass",'
            - '           "End": true'
            - "       }"
            - "   }"
            - "}"
      RoleArn:
        Fn::GetAtt:
          - stepFunctionsStateExecutionRole
          - Arn

Outputs:
  EMRBucket:
    Description: EMR data output dir
    Value: !Ref emrDataOutputBucket
  EMRLogBucket:
    Description: EMR log dir
    Value: !Ref emrLogBucket
  EMRPrivateKey:
    Description: EMR private key path in parameter store
    Value: !Ref emrPrivateKey